
# 9.21: Patientor, step2 - Single Patient Page

We started by the easy stuff, we created the new method for fetching a single patient in the service.

We must fetch the patient data in the `PatienView` component, because the list of patients that we have in the rest of the App only has non-sensitive data in it. We make use of the `useParams` hook in order to retrieve the `id` from the route:

```ts
const patientId = useParams().id;
```

We fetch the patient inside a `useEffect` hook. We then use the patient's gender to choose the correct Icon element for their gender:

```ts
switch (patient?.gender) {
    case Gender.Male:
      icon = <Male></Male>;
      break;
    case Gender.Female:
      icon = <Female></Female>;
      break;
    case Gender.Other:
      icon = <Transgender></Transgender>;
      break;
    default:
      break;
  }
```

# 9.25: Patientor, step6

On each of the specific type of entries, we're going to use the [[Fullstack Course#Extract]] utility type to extract each specific type in the props of the component:

```ts
type ExtractedHospitalEntry = Extract<Entry, { type: 'Hospital' }>;

interface Props {
  entry: ExtractedHospitalEntry;
}
```

In the above code, the `Entry` type is a Union Type, we can use the `Extract` type utility to extract the type that has the `type` "Hospital".

In the Patient View component we're passing each Entry to the `EntryDetails` component, before doing so, we're building a Diagnoses array which contain all the info required to display the diagnoses:

```ts
patient?.entries.map((entry) => {
	entry.diagnosisCodes &&
	  (entry.diagnoses = buildDiagnosesArray(entry.diagnosisCodes));
	return (
	  <Box key={entry.id}>
		<EntryDetails entry={entry} />
	  </Box>
	);
}
```

We went with the approach suggested by the Course, we have a `EntryDetails` component that uses a `switch` statement to render each type of Entry. I think here, we could use some refactoring, we're duplicating a lot of code inside each of the Entry Type components. #reviewSolutionAfterSubmission 

# 9.26: Patientor, step7

## Parsing New Entries

We must parse each entry separately because they all have different fields, the most complex one was the Occupational Entry, in there we have an optional `sickLeave` field which itself is an object with two other fields. 

We must check if the field exists in the Object we retrieved from the request and add it to our NewEntry if so:

``` ts
  case 'OccupationalHealthcare':
	if ('employerName' in entryObj) {
	  const newOccupationalEntry: NewEntry = {
		//.... other fields go here
		employerName: parseString(entryObj.employerName),
		...('sickLeave' in entryObj && {
		  sickLeave: parseSickLeave(entryObj.sickLeave),
		}), // Conditionally add sickLeave if the request has it
	  };
	  return newOccupationalEntry;
	}
	break;

```

Above we used spread syntax to add the `sickLeave` field only if `entryObj` has that property. We also use the method `parseSickLeave` to make sure the object has the correct fields and types:

```ts
function parseSickLeave(object: unknown): {
  startDate: string;
  endDate: string;
} {
  if (
    !object ||
    typeof object !== 'object' ||
    !('startDate' in object) ||
    !('endDate' in object)
  ) {
    throw new Error(`Incorrect Sick Leave : ${object}`);
  }
  return {
    startDate: parseDate(object.startDate),
    endDate: parseDate(object.endDate),
  };
}

```

## Health Ratings Type Guards

We are using a numeric Enum to manage the Health Ratings, so in order to guard them we used the following function:

```ts
function isHealthCheckRating(param: number): param is HealthCheckRating {
  return Object.values(HealthCheckRating)
    .filter((v) => !isNaN(Number(v)))
    .includes(param);
}
```

We used the [[Fullstack Course#Iterating Enums]] trick, and once we have the values we can check if the value we're passed by the request is contained.

# Omitting properties in Union Types

As seen in this [GitHube issue](https://github.com/microsoft/TypeScript/issues/42680) Omit types work a little bit weirdly